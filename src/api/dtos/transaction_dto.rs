/*
 * Copyright 2018 ProximaX Limited. All rights reserved.
 * Use of this source code is governed by the Apache 2.0
 * license that can be found in the LICENSE file.
 */

use ::std::str::FromStr;

use crate::{
    account::{Address, PublicAccount},
    models::Result,
    mosaic::{Mosaic, MosaicId},
    network::extract_network_type,
    transaction::{
        AbstractTransaction, BlockchainTimestamp, Deadline, HashValue, internal::extract_version,
        LockFundsTransaction, SignedTransaction, Transaction, TransactionInfo, TransactionStatus,
        TransactionType, TransferTransaction,
    },
};
use crate::models::transaction::Signature;

use super::{MessageDto, MosaicDto, Uint64Dto};

/// The hash algorithm used to hash te proof:
///* 0 (Op_Sha3_256)  - The proof is hashed using sha3 256.
///* 1 (Op_Keccak_256)  - The proof is hashed using Keccak (ETH compatibility).
///* 2 (Op_Hash_160)  - The proof is hashed twice: first with Sha-256 and then with RIPEMD-160 (bitcoin’s OP_HASH160).
///* 3 (Op_Hash_256)  - The proof is hashed twice with Sha-256 (bitcoin’s OP_HASH256).
#[derive(Serialize, Deserialize)]
pub(crate) enum HashAlgorithm {
    #[serde(rename = "0")]
    _0,
    #[serde(rename = "1")]
    _1,
    #[serde(rename = "2")]
    _2,
    #[serde(rename = "3")]
    _3,
}

#[typetag::serde]
pub(crate) trait TransactionDto {
    fn compact(&self) -> Result<Box<dyn Transaction>>;
}

#[derive(Clone, Serialize, Deserialize)]
pub(crate) struct AbstractTransactionDto {
    /// The signature of the entity. The signature was generated by the signer and
    /// can be used to validate tha the entity data was not modified by a node.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub signature: Option<String>,
    /// The public key of the entity signer formatted as hexadecimal.
    pub signer: String,
    /// The entity version. The higher byte represents the network identifier:
    /// * 0x68 (MAIN_NET) - PUBLIC main network.
    /// * 0x98 (TEST_NET) - PUBLIC test network.
    /// * 0x60 (MIJIN) - PRIVATE network.
    /// * 0x90 (MIJIN_TEST) - PRIVATE test network.
    pub version: u32,
    pub r#type: u16,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_fee: Option<Uint64Dto>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub deadline: Option<Uint64Dto>,
}

impl AbstractTransactionDto {
    pub fn compact(&self, info: TransactionInfo) -> crate::Result<AbstractTransaction> {
        let dto = self;

        let network_type = extract_network_type(self.version as u32);

        let version = extract_version(self.version as u32);

        let signer = PublicAccount::from_public_key(&dto.signer, network_type)?;

        let deadline = if let Some(item) = &dto.deadline {
            let timestamp = BlockchainTimestamp::new(*item.compact() as i64);
            Some(Deadline::from(timestamp))
        } else {
            None
        };

        let max_fee = if let Some(item) = &dto.max_fee {
            Some(item.compact())
        } else {
            None
        };

        let transaction_type = TransactionType::from(dto.r#type);

        let signature = if let Some(s) = &dto.signature {
            Some(Signature::from_str(s)?)
        } else {
            None
        };

        Ok(AbstractTransaction {
            transaction_info: Some(info),
            network_type,
            signature,
            signer,
            version,
            transaction_type,
            max_fee,
            deadline,
        })
    }
}

#[derive(Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub(crate) struct TransactionMetaDto {
    #[serde(rename = "height", skip_serializing_if = "Option::is_none")]
    height: Option<Uint64Dto>,
    #[serde(rename = "index", skip_serializing_if = "Option::is_none")]
    index: Option<u32>,
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    id: Option<String>,
    #[serde(rename = "hash", skip_serializing_if = "Option::is_none")]
    transaction_hash: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    merkle_component_hash: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    aggregate_id: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    aggregate_hash: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    unique_aggregate_hash: Option<String>,
}

impl TransactionMetaDto {
    pub fn compact(&self) -> crate::Result<TransactionInfo> {
        let dto = self.clone();

        let aggregate_hash = if let Some(t) = dto.aggregate_hash {
            Some(HashValue::from_str(&t)?)
        } else {
            None
        };

        let aggregate_id = if let Some(t) = dto.aggregate_id {
            Some(t)
        } else {
            None
        };

        let unique_aggregate_hash = if let Some(t) = dto.unique_aggregate_hash {
            Some(HashValue::from_str(&t)?)
        } else {
            None
        };

        let transaction_hash = if let Some(t) = dto.transaction_hash {
            Some(HashValue::from_str(&t)?)
        } else {
            None
        };

        let merkle_component_hash = if let Some(t) = dto.merkle_component_hash {
            Some(HashValue::from_str(&t)?)
        } else {
            None
        };

        let index = if let Some(i) = dto.index { i } else { 0 };

        let id = if let Some(item) = dto.id {
            item
        } else {
            String::new()
        };

        let height = if let Some(h) = dto.height {
            h.compact()
        } else {
            crate::Uint64::default()
        };

        Ok(TransactionInfo {
            height,
            index,
            id,
            hash: transaction_hash,
            merkle_component_hash,
            aggregate_hash,
            aggregate_id,
            unique_aggregate_hash,
        })
    }
}

#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub(crate) struct TransactionStatusDto {
    #[serde(rename = "group", skip_serializing_if = "Option::is_none")]
    group: Option<String>,
    #[serde(rename = "status")]
    status: String,
    #[serde(rename = "hash", skip_serializing_if = "Option::is_none")]
    hash: Option<String>,
    #[serde(rename = "deadline", skip_serializing_if = "Option::is_none")]
    deadline: Option<Uint64Dto>,
    #[serde(rename = "height", skip_serializing_if = "Option::is_none")]
    height: Option<Uint64Dto>,
}

impl TransactionStatusDto {
    pub fn compact(&self) -> crate::Result<TransactionStatus> {
        let dto = &self.to_owned();

        let deadline = if let Some(value) = &dto.deadline {
            let blockchain_timestamp = BlockchainTimestamp::new(*value.compact() as i64);
            Some(Deadline::from(blockchain_timestamp))
        } else {
            None
        };

        let height = if let Some(value) = &dto.height {
            Some(value.compact())
        } else {
            None
        };

        Ok(TransactionStatus::new(
            dto.group.clone().unwrap(),
            dto.status.clone(),
            HashValue::from_str(&dto.hash.as_ref().unwrap())?,
            deadline,
            height,
        ))
    }
}

#[derive(Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub(crate) struct TransferTransactionInfoDto {
    pub meta: TransactionMetaDto,
    pub transaction: TransferTransactionDto,
}

#[typetag::serde]
impl TransactionDto for TransferTransactionInfoDto {
    fn compact(&self) -> Result<Box<dyn Transaction>> {
        let dto = self.transaction.clone();
        let info = self.meta.compact()?;

        let abs_transaction = dto.r#abstract.compact(info)?;

        let mut mosaics: Vec<Mosaic> = vec![];
        if let Some(value) = &dto.mosaics {
            for mosaic in value {
                mosaics.push(mosaic.compact());
            }
        };

        let recipient = Address::from_encoded(&dto.recipient)?;

        Ok(Box::new(TransferTransaction {
            abs_transaction,
            recipient,
            mosaics,
            message: dto.message.compact(),
        }))
    }
}

/// TransferTransactionDto : Transaction that transfers mosaics and messages to another account.
#[derive(Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub(crate) struct TransferTransactionDto {
    #[serde(flatten)]
    r#abstract: AbstractTransactionDto,
    pub recipient: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mosaics: Option<Vec<MosaicDto>>,
    pub message: MessageDto,
}

/// HashLockTransactionDto :
/// Transaction to lock funds before sending an aggregate bonded transaction.
#[derive(Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub(crate) struct HashLockTransactionDto {
    #[serde(flatten)]
    r#abstract: AbstractTransactionDto,
    mosaic_id: Uint64Dto,
    amount: Uint64Dto,
    duration: Uint64Dto,
    hash: String,
}

#[derive(Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub(crate) struct HashLockTransactionInfoDto {
    meta: TransactionMetaDto,
    transaction: HashLockTransactionDto,
}

#[typetag::serde]
impl TransactionDto for HashLockTransactionInfoDto {
    fn compact(&self) -> Result<Box<dyn Transaction>> {
        let dto = self.transaction.clone();
        let info = self.meta.compact()?;

        let abs_transaction = dto.r#abstract.compact(info)?;

        let mosaic = Mosaic::new(
            MosaicId::from(dto.mosaic_id.compact()),
            dto.amount.compact().as_u64(),
        );

        Ok(Box::new(LockFundsTransaction {
            abs_transaction,
            mosaic,
            duration: dto.duration.compact(),
            signed_transaction: SignedTransaction::new(
                TransactionType::AggregateBonded,
                "".to_string(),
                HashValue::from_str(&dto.hash)?,
            ),
        }))
    }
}
