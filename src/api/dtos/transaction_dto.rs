/*
 * Copyright 2018 ProximaX Limited. All rights reserved.
 * Use of this source code is governed by the Apache 2.0
 * license that can be found in the LICENSE file.
 */

use ::std::str::FromStr;
use std::fmt::Debug;

use crypto::Signature;

use crate::{
	account::{Address, PublicAccount},
	helpers::{hex_decode, TransactionHash},
	message::Message,
	mosaic::{Mosaic, MosaicId},
	namespace::NamespaceId,
	network::NetworkType,
	transaction::{
		internal::extract_version, BlockchainTimestamp, BlockchainUpgradeTransaction,
		CommonTransaction, Deadline, LockFundsTransaction, MetadataTransaction,
		MetadataV2AccountTransaction, MetadataV2MosaicTransaction, MetadataV2NamespaceTransaction,
		NetworkConfigTransaction, SignedTransaction, Transaction, TransactionInfo,
		TransactionStatus, TransactionType, TransferTransaction,
	},
};

use super::{MessageDto, MosaicDto, Uint64Dto};

/// The hash algorithm used to hash te proof:
///* 0 (Op_Sha3_256)  - The proof is hashed using sha3 256.
///* 1 (Op_Keccak_256)  - The proof is hashed using Keccak (ETH compatibility).
///* 2 (Op_Hash_160)  - The proof is hashed twice: first with Sha-256 and then with RIPEMD-160 (bitcoin’s OP_HASH160).
///* 3 (Op_Hash_256)  - The proof is hashed twice with Sha-256 (bitcoin’s OP_HASH256).
#[derive(Debug, Serialize, Deserialize)]
pub(crate) enum HashAlgorithm {
	#[serde(rename = "0")]
	_0,
	#[serde(rename = "1")]
	_1,
	#[serde(rename = "2")]
	_2,
	#[serde(rename = "3")]
	_3,
}

#[typetag::serde]
pub(crate) trait TransactionDto: Debug {
	fn compact(&self) -> anyhow::Result<Box<dyn Transaction>>;
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub(crate) struct AbstractTransactionDto {
	/// The signature of the entity. The signature was generated by the signer and
	/// can be used to validate tha the entity data was not modified by a node.
	#[serde(skip_serializing_if = "Option::is_none")]
	pub signature: Option<String>,
	/// The public key of the entity signer formatted as hexadecimal.
	pub signer: String,
	/// The entity version. The higher byte represents the network identifier:
	/// * 0x68 (MAIN_NET) - PUBLIC main network.
	/// * 0x98 (TEST_NET) - PUBLIC test network.
	/// * 0x60 (MIJIN) - PRIVATE network.
	/// * 0x90 (MIJIN_TEST) - PRIVATE test network.
	pub version: u32,
	pub r#type: u16,
	#[serde(rename = "maxFee", skip_serializing_if = "Option::is_none")]
	pub max_fee: Option<Uint64Dto>,
	#[serde(skip_serializing_if = "Option::is_none")]
	pub deadline: Option<Uint64Dto>,
}

impl AbstractTransactionDto {
	pub fn compact(&self, info: TransactionInfo) -> anyhow::Result<CommonTransaction> {
		let dto = self;

		let network_type = NetworkType::from_transaction_version(self.version as u32)?;

		let version = extract_version(self.version as u32);

		let signer = PublicAccount::from_public_key(&dto.signer, network_type)?;

		let deadline = if let Some(item) = &dto.deadline {
			let timestamp = BlockchainTimestamp::new(item.compact() as i64);
			Some(Deadline::from(timestamp))
		} else {
			None
		};

		let max_fee = if let Some(item) = &dto.max_fee { Some(item.compact()) } else { None };

		let transaction_type: TransactionType = dto.r#type.try_into()?;

		let signature = if let Some(s) = &dto.signature {
			Some(Signature::from_bytes(&hex::decode(s).unwrap()).unwrap())
		} else {
			None
		};

		Ok(CommonTransaction {
			transaction_info: Some(info),
			network_type,
			signature,
			signer: Some(signer),
			version,
			transaction_type,
			max_fee,
			deadline,
		})
	}
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub(crate) struct TransactionMetaDto {
	#[serde(rename = "height", skip_serializing_if = "Option::is_none")]
	height: Option<Uint64Dto>,
	#[serde(rename = "index", skip_serializing_if = "Option::is_none")]
	index: Option<u32>,
	#[serde(rename = "id", skip_serializing_if = "Option::is_none")]
	id: Option<String>,
	#[serde(rename = "hash", skip_serializing_if = "Option::is_none")]
	transaction_hash: Option<String>,
	#[serde(skip_serializing_if = "Option::is_none")]
	merkle_component_hash: Option<String>,
	#[serde(skip_serializing_if = "Option::is_none")]
	aggregate_id: Option<String>,
	#[serde(skip_serializing_if = "Option::is_none")]
	aggregate_hash: Option<String>,
	#[serde(skip_serializing_if = "Option::is_none")]
	unique_aggregate_hash: Option<String>,
}

impl TransactionMetaDto {
	pub fn compact(&self) -> anyhow::Result<TransactionInfo> {
		let dto = self.clone();

		let aggregate_hash = if let Some(t) = dto.aggregate_hash {
			Some(TransactionHash::from_str(&t)?)
		} else {
			None
		};

		let aggregate_id = if let Some(t) = dto.aggregate_id { Some(t) } else { None };

		let unique_aggregate_hash = if let Some(t) = dto.unique_aggregate_hash {
			Some(TransactionHash::from_str(&t)?)
		} else {
			None
		};

		let transaction_hash = if let Some(t) = dto.transaction_hash {
			Some(TransactionHash::from_str(&t)?)
		} else {
			None
		};

		let merkle_component_hash = if let Some(t) = dto.merkle_component_hash {
			Some(TransactionHash::from_str(&t)?)
		} else {
			None
		};

		let index = if let Some(i) = dto.index { i } else { 0 };

		let id = if let Some(item) = dto.id { item } else { String::new() };

		let height = if let Some(h) = dto.height { h.compact() } else { 0 };

		Ok(TransactionInfo {
			height,
			index,
			id,
			hash: transaction_hash,
			merkle_component_hash,
			aggregate_hash,
			aggregate_id,
			unique_aggregate_hash,
		})
	}
}

#[derive(Debug, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub(crate) struct TransactionStatusDto {
	#[serde(rename = "group", skip_serializing_if = "Option::is_none")]
	group: Option<String>,
	#[serde(rename = "status")]
	status: String,
	#[serde(rename = "hash", skip_serializing_if = "Option::is_none")]
	hash: Option<String>,
	#[serde(rename = "deadline", skip_serializing_if = "Option::is_none")]
	deadline: Option<Uint64Dto>,
	#[serde(rename = "height", skip_serializing_if = "Option::is_none")]
	height: Option<Uint64Dto>,
}

impl TransactionStatusDto {
	pub fn compact(&self) -> anyhow::Result<TransactionStatus> {
		let dto = &self.to_owned();

		let deadline = if let Some(value) = &dto.deadline {
			let blockchain_timestamp = BlockchainTimestamp::new(value.compact() as i64);
			Some(Deadline::from(blockchain_timestamp))
		} else {
			None
		};

		let height = if let Some(value) = &dto.height { Some(value.compact()) } else { None };

		Ok(TransactionStatus::new(
			dto.group.clone().unwrap(),
			dto.status.clone(),
			TransactionHash::from_str(&dto.hash.as_ref().unwrap())?,
			deadline,
			height,
		))
	}
}

#[derive(Clone, Debug, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub(crate) struct TransferTransactionInfoDto {
	pub meta: TransactionMetaDto,
	pub transaction: TransferTransactionDto,
}

#[typetag::serde]
impl TransactionDto for TransferTransactionInfoDto {
	fn compact(&self) -> anyhow::Result<Box<dyn Transaction>> {
		let dto = self.transaction.clone();
		let info = self.meta.compact()?;

		let common = dto.r#abstract.compact(info)?;

		let mut mosaics: Vec<Mosaic> = vec![];
		if let Some(value) = &dto.mosaics {
			for mosaic in value {
				mosaics.push(mosaic.compact());
			}
		};

		let recipient = Address::from_encoded(&dto.recipient)?;

		Ok(Box::new(TransferTransaction {
			common,
			recipient: Box::new(recipient),
			mosaics,
			message: dto
				.message
				.map_or(Box::new(<dyn Message>::empty_message()), |item| item.compact()),
		}))
	}
}

/// TransferTransactionDto : Transaction that transfers mosaics and messages to another account.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub(crate) struct TransferTransactionDto {
	#[serde(flatten)]
	r#abstract: AbstractTransactionDto,
	pub recipient: String,
	#[serde(skip_serializing_if = "Option::is_none")]
	pub mosaics: Option<Vec<MosaicDto>>,
	#[serde(skip_serializing_if = "Option::is_none")]
	pub message: Option<MessageDto>,
}

/// HashLockTransactionDto :
/// Transaction to lock funds before sending an aggregate bonded transaction.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub(crate) struct HashLockTransactionDto {
	#[serde(flatten)]
	r#abstract: AbstractTransactionDto,
	mosaic_id: Uint64Dto,
	amount: Uint64Dto,
	duration: Uint64Dto,
	hash: String,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub(crate) struct HashLockTransactionInfoDto {
	meta: TransactionMetaDto,
	transaction: HashLockTransactionDto,
}

#[typetag::serde]
impl TransactionDto for HashLockTransactionInfoDto {
	fn compact(&self) -> anyhow::Result<Box<dyn Transaction>> {
		let dto = self.transaction.clone();
		let info = self.meta.compact()?;

		let common = dto.r#abstract.compact(info)?;

		let mosaic = Mosaic::create(MosaicId::from(dto.mosaic_id.compact()), dto.amount.compact())?;

		Ok(Box::new(LockFundsTransaction {
			common,
			mosaic,
			duration: dto.duration.compact(),
			signed_transaction: SignedTransaction {
				entity_type: TransactionType::AggregateBonded,
				payload: "".to_string(),
				hash: TransactionHash::from_str(&dto.hash).unwrap(),
			},
		}))
	}
}

#[derive(Clone, Debug, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub(crate) struct NetworkConfigTransactionInfoDto {
	meta: TransactionMetaDto,
	transaction: NetworkConfigTransactionDto,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub(crate) struct NetworkConfigTransactionDto {
	#[serde(flatten)]
	r#abstract: AbstractTransactionDto,
	pub network_config: String,
}

#[typetag::serde]
impl TransactionDto for NetworkConfigTransactionInfoDto {
	fn compact(&self) -> anyhow::Result<Box<dyn Transaction>> {
		let dto = self.transaction.clone();
		let info = self.meta.compact()?;
		let common = dto.r#abstract.compact(info)?;

		Ok(Box::new(NetworkConfigTransaction {
			common,
			network_config: dto.network_config.to_owned(),
		}))
	}
}

#[derive(Clone, Debug, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub(crate) struct BlockchainUpgradeTransactionInfoDto {
	meta: TransactionMetaDto,
	transaction: BlockchainUpgradeTransactionDto,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub(crate) struct BlockchainUpgradeTransactionDto {
	#[serde(flatten)]
	r#abstract: AbstractTransactionDto,
	pub new_blockchain_version: Uint64Dto,
	pub upgrade_period: Uint64Dto,
}

#[typetag::serde]
impl TransactionDto for BlockchainUpgradeTransactionInfoDto {
	fn compact(&self) -> anyhow::Result<Box<dyn Transaction>> {
		let dto = self.transaction.clone();
		let info = self.meta.compact()?;
		let common = dto.r#abstract.compact(info)?;

		Ok(Box::new(BlockchainUpgradeTransaction {
			common,
			new_blockchain_version: dto.new_blockchain_version.compact(),
			upgrade_period: dto.upgrade_period.compact(),
		}))
	}
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub(crate) struct MetaDataEntryTransactionDto {
	#[serde(flatten)]
	r#abstract: AbstractTransactionDto,
	pub target_key: String,
	pub scoped_metadata_key: Uint64Dto,
	pub value_size_delta: u16,
	pub value_size: u16,
	pub value: String,
	pub target_mosaic_id: Option<Uint64Dto>,
	pub target_namespace_id: Option<Uint64Dto>,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub(crate) struct MetaDataEntryTransactionInfoDto {
	meta: TransactionMetaDto,
	transaction: MetaDataEntryTransactionDto,
}

#[typetag::serde]
impl TransactionDto for MetaDataEntryTransactionInfoDto {
	fn compact(&self) -> anyhow::Result<Box<dyn Transaction>> {
		let dto = self.transaction.clone();
		let info = self.meta.compact()?;
		let common = dto.r#abstract.compact(info)?;

		let metadata = MetadataTransaction {
			target_public_account: PublicAccount::from_public_key(
				&dto.target_key,
				common.network_type.clone(),
			)?,
			common,
			scoped_metadata_key: dto.scoped_metadata_key.compact(),
			value_size_delta: dto.value_size_delta,
			value: String::from_utf8(hex_decode(&dto.value)).unwrap_or_default(),
		};

		Ok(match TransactionType::from(dto.r#abstract.r#type) {
			TransactionType::AccountMetadataV2 => Box::new(MetadataV2AccountTransaction(metadata)),
			TransactionType::MosaicMetadataV2 => Box::new(MetadataV2MosaicTransaction {
				metadata,
				mosaic_id: MosaicId::from(dto.target_mosaic_id.unwrap().compact()),
			}),
			TransactionType::NamespaceMetadataV2 => Box::new(MetadataV2NamespaceTransaction {
				metadata,
				namespace_id: NamespaceId::from(dto.target_namespace_id.unwrap().compact()),
			}),
			_ => return Err(anyhow!("Invalid metadata transaction")),
		})
	}
}
