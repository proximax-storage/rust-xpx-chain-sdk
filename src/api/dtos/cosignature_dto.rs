/*
 * Copyright 2018 ProximaX Limited. All rights reserved.
 * Use of this source code is governed by the Apache 2.0
 * license that can be found in the LICENSE file.
 */

use crate::{
    account::PublicAccount,
    multisig::{CosignatoryModification, Cosignature, MultisigModificationType},
    network::NetworkType,
};

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub(crate) struct CosignatoryModificationDto {
    #[serde(rename = "type")]
    modification_type: u8,
    cosignatory_public_key: String,
}

impl CosignatoryModificationDto {
    pub fn compact(&self, network_type: NetworkType) -> CosignatoryModification {
        let public_account =
            PublicAccount::from_public_key(&self.cosignatory_public_key, network_type).unwrap();

        CosignatoryModification {
            modification_type: MultisigModificationType::from(self.modification_type),
            public_account,
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub(crate) struct CosignatureDto {
    /// The signature of the entity.
    /// The signature was generated by the signer and can be used to validate tha the entity data
    /// was not modified by a node.
    signature: String,
    /// The public account of the cosignatory.
    signer: String,
}

impl CosignatureDto {
    pub fn compact(&self, network_type: NetworkType) -> Cosignature {
        let signer = PublicAccount::from_public_key(&self.signer, network_type).unwrap();

        Cosignature { signature: (&self.signature).parse().unwrap(), signer }
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub(crate) struct CosignatureDtoAllOf {
    /// The public key of the transaction signer.
    signer: String,
}
