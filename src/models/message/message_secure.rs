/*
 * Copyright 2018 ProximaX Limited. All rights reserved.
 * Use of this source code is governed by the Apache 2.0
 * license that can be found in the LICENSE file.
 */

use anyhow::Result;

use crate::{
    account::{Account, PublicAccount},
    crypto::{Ed25519BlockCipher, PublicKey},
    errors_const,
    helpers::{hex_decode, hex_encode, is_hex},
};

use super::{Message, MessageType, PlainMessage};

/// An encrypted message model defines a secure message that has been encrypted using
/// the Sirius's SDK libraries.
///
/// Please note:
/// The strategy to encrypt and decrypt should be consistent between the different SDKs.
/// A client may send a transaction using a different encryption strategy than the recipient.
/// Even though the same encryption algorithm is used, the outcome may still be different
/// depending on the encoding process.
///
/// The encryption strategy this SDK uses is UTF-8 and hex encodings:
/// "plain text" string -> utf8 byte array -> encrypted byte array -> hex string
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SecureMessage {
    /// Message type
    #[serde(rename = "type")]
    pub r#type: MessageType,
    /// Message payload.
    pub payload: String,
}

impl SecureMessage {
    /// Creates an encrypted message from [plainTextMessage].
    ///
    /// The message is encrypted using a shared key generated by the [senderPrivateKey] and
    /// the [recipient_public_key]. The recipient can decrypt this message using this shared key by
    /// taking the sender's public key and the recipient's public key.
    pub fn create(
        sender_account: &Account,
        recipient_public_account: &PublicAccount,
        payload: &str,
    ) -> Result<Self> {
        ensure!(!payload.is_empty(), "message must not be empty.");

        // Encrypts the message
        let mut block_cipher = Ed25519BlockCipher::new(&sender_account.key_pair.secret);

        let payload_vec =
            if is_hex(&payload) { hex_decode(payload) } else { payload.as_bytes().to_vec() };

        let encrypted_payload = block_cipher.encrypt(
            &payload_vec,
            &PublicKey::from_bytes(recipient_public_account.to_builder())
                .map_err(|err| anyhow!(err))?,
        );

        Ok(SecureMessage {
            r#type: MessageType::SecureMessageType,
            payload: hex_encode(&encrypted_payload),
        })
    }

    /// It creates a `SecureMessage` from the payload hex without the 01 prefix.
    /// The 01 prefix will be attached to the final payload.
    ///
    pub fn from_hex_payload(payload: &str) -> Result<Self> {
        ensure!(is_hex(payload), errors_const::ERR_INVALID_PAYLOAD_HEX);

        Ok(SecureMessage { r#type: MessageType::SecureMessageType, payload: payload.to_string() })
    }

    /// It creates a `SecureMessage` from the given bytes.
    ///
    pub fn from_bytes(bytes: &[u8]) -> Result<Self> {
        ensure!(!bytes.is_empty(), "bytes must not be empty.");
        let payload = hex::encode(bytes);
        Self::from_hex_payload(&payload)
    }

    /// Decrypts an `SecureMessage`.
    ///
    /// Returns a `PlainMessage`.
    pub fn decrypt(
        &self,
        recipient_account: &Account,
        sender_public_account: PublicAccount,
    ) -> Result<PlainMessage> {
        let mut block_cipher = Ed25519BlockCipher::new(&recipient_account.key_pair.secret);

        let encrypted_payload = block_cipher.decrypt(
            &hex_decode(&self.payload),
            &PublicKey::from_bytes(sender_public_account.to_builder())
                .map_err(|err| anyhow!(err))?,
        );

        let encrypted_payload = encrypted_payload.unwrap();

        let payload = match String::from_utf8(encrypted_payload.to_owned()) {
            Ok(payload) => payload,
            Err(_) => hex_encode(&encrypted_payload),
        };

        Ok(PlainMessage::create(&payload))
    }
}

#[typetag::serde]
impl Message for SecureMessage {
    fn message_type(&self) -> MessageType {
        self.r#type
    }
    fn payload(&self) -> String {
        self.payload.to_owned()
    }
    fn box_clone(&self) -> Box<dyn Message + 'static> {
        Box::new((*self).clone())
    }
}

impl core::fmt::Display for SecureMessage {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        write!(f, "{}", serde_json::to_string_pretty(&self).unwrap_or_default())
    }
}

#[cfg(test)]
pub mod tests {
    use lazy_static::lazy_static;

    use crate::account::Account;
    use crate::message::SecureMessage;
    use crate::network::NetworkType;

    const SENDER_PRIVATE_KEY: &str =
        "2602F4236B199B3DF762B2AAB46FC3B77D8DDB214F0B62538D3827576C46C108";
    const RECIPIENT_PRIVATE_KEY: &str =
        "B72F2950498111BADF276D6D9D5E345F04E0D5C9B8342DA983C3395B4CF18F08";

    lazy_static! {
		static ref SENDER: Account =
			Account::from_hex_private_key(SENDER_PRIVATE_KEY, NetworkType::PrivateTest).unwrap();
		static ref RECIPIENT: Account =
			Account::from_hex_private_key(RECIPIENT_PRIVATE_KEY, NetworkType::PrivateTest).unwrap();
	}

    #[test]
    fn test_should_create_from_a_dto() {
        let payload = "test transaction";
        let encrypted_message = SecureMessage::from_hex_payload(&payload);

        assert!(encrypted_message.is_err());
    }

    #[test]
    fn test_should_return_encrypted_message_dto() {
        let encrypted_message =
            SENDER.encrypt_message(RECIPIENT.public_account, "test transaction").unwrap();
        let plain_message =
            RECIPIENT.decrypt_message(SENDER.public_account, encrypted_message).unwrap();

        assert_eq!(plain_message.payload, "test transaction");
    }

    #[test]
    fn test_should_decrypt_message_from_raw_encrypted_message_payload() {
        let encrypted_message = SENDER
            .encrypt_message(RECIPIENT.public_account, "Testing simple transfer")
            .unwrap();
        let encrypted_message_from_payload =
            SecureMessage::from_hex_payload(&encrypted_message.payload).unwrap();
        let plain_message = RECIPIENT
            .decrypt_message(SENDER.public_account, encrypted_message_from_payload)
            .unwrap();

        assert_eq!(plain_message.payload, "Testing simple transfer");
    }
}
