/*
 * Copyright 2018 ProximaX Limited. All rights reserved.
 * Use of this source code is governed by the Apache 2.0
 * license that can be found in the LICENSE file.
 */

use std::borrow::Borrow;

use crate::{
    crypto::{Ed25519BlockCipher, PublicKey},
    errors_const,
    helpers::{hex_decode, hex_encode, is_hex},
    models::{
        account::{Account, PublicAccount},
        message::PlainMessage,
    },
    Result,
};

use super::{Message, MessageType};

/// An encrypted message model defines a secure message that has been encrypted using
/// the Sirius's SDK libraries.
///
/// Please note:
/// The strategy to encrypt and decrypt should be consistent between the different SDKs.
/// A client may send a transaction using a different encryption strategy than the recipient.
/// Even though the same encryption algorithm is used, the outcome may still be different
/// depending on the encoding process.
///
/// The encryption strategy this SDK uses is UTF-8 and hex encodings:
/// "plain text" string -> utf8 byte array -> encrypted byte array -> hex string
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SecureMessage {
    #[serde(rename = "type")]
    _type: MessageType,
    pub payload: String,
}

impl SecureMessage {
    /// Creates an encrypted message from [plainTextMessage].
    ///
    /// The message is encrypted using a shared key generated by the [senderPrivateKey] and
    /// the [recipient_public_key]. The recipient can decrypt this message using this shared key by
    /// taking the sender's public key and the recipient's public key.
    pub fn create(
        sender_account: &Account,
        recipient_public_account: &PublicAccount,
        payload: &str,
    ) -> Result<Self> {
        // Encrypts the message
        let mut block_cipher = Ed25519BlockCipher::new(&sender_account.key_pair.secret);

        let payload_vec = if is_hex(&payload) {
            hex_decode(payload)
        } else {
            payload.as_bytes().to_vec()
        };

        let encrypted_payload = block_cipher.encrypt(
            &payload_vec,
            &PublicKey::from_bytes(recipient_public_account.to_bytes())?,
        );

        Ok(SecureMessage {
            _type: MessageType::SecureMessageType,
            payload: hex_encode(&encrypted_payload),
        })
    }

    /// Creates an encrypted message from [payload].
    ///
    /// The [payload] is a hex encoded string.
    pub fn from_hex_payload(payload: &str) -> Result<Self> {
        ensure!(is_hex(payload), errors_const::ERR_INVALID_PAYLOAD_HEX);

        let msg_s = SecureMessage {
            _type: MessageType::SecureMessageType,
            payload: payload.to_string(),
        };
        Ok(msg_s)
    }

    /// Decrypts an [encryptedMessage].
    ///
    /// Returns a PlainMessage.
    pub fn decrypt(
        &self,
        recipient_account: &Account,
        sender_public_account: &PublicAccount,
    ) -> Result<PlainMessage> {
        let mut block_cipher = Ed25519BlockCipher::new(&recipient_account.key_pair.secret);

        let encrypted_payload = block_cipher.decrypt(
            &hex_decode(&self.payload),
            &PublicKey::from_bytes(sender_public_account.to_bytes())?,
        );

        let encrypted_payload = encrypted_payload.unwrap();

        let payload = match String::from_utf8(encrypted_payload.to_owned()) {
            Ok(payload) => payload,
            Err(_) => hex_encode(&encrypted_payload),
        };

        Ok(PlainMessage::new(&payload))
    }
}

impl Message for SecureMessage {
    fn message_type(&self) -> &MessageType {
        &self._type.borrow()
    }

    fn payload_to_bytes(&self) -> &[u8] {
        self.payload.as_bytes()
    }

    fn box_clone(&self) -> Box<dyn Message + 'static> {
        Box::new((*self).clone())
    }
}

impl core::fmt::Display for SecureMessage {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(&self).unwrap_or_default()
        )
    }
}
